{
  "name": "tilesplash",
  "description": "a light and quick nodejs webserver for serving topojson vector tiles from a postgis backend",
  "version": "1.2.0",
  "maintainers": [
    {
      "name": "Tristan Davies",
      "email": "npm@tristan.io"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/faradayio/tilesplash.git"
  },
  "main": "lib/index.js",
  "scripts": {
    "test": "mocha"
  },
  "devDependencies": {
    "request": "~2.36.0",
    "mocha": "~1.20.0"
  },
  "dependencies": {
    "express": "~4.4.1",
    "topojson": "1.6.9",
    "pg": "~3.3.0",
    "sphericalmercator": "~1.0.2",
    "async": "~0.9.0",
    "caching": "git+ssh://git@github.com:faradayio/node-caching.git"
  },
  "readme": "TILESPLASH\n==========\n\na light and quick nodejs webserver for serving topojson vector tiles from a postgis backend. inspired by [Michal Migurski](http://mike.teczno.com/)'s [TileStache](http://tilestache.org/)\n\n<img src=\"https://farm4.staticflickr.com/3854/14427710520_f3ba841c36_c.jpg\"/>\n\n#Dependencies\n\nTilesplash depends on `node` and `npm`\n\n#Installation\n\n```bash\nnpm install tilesplash\n```\n\n#Example\n\nHere's a simple tile server with one layer\n\n```javascript\nvar Tilesplash = require('tilesplash');\n\nvar app = new Tilesplash('postgres://tristan@localhost/tilesplash_test');\n\napp.layer('test_layer', function(req, res, tile, done){\n  done(null, 'SELECT ST_AsGeoJSON(the_geom) as the_geom_geojson FROM tilesplash_test WHERE ST_Intersects(the_geom, !bbox_4326!)');\n});\n\napp.server.listen(3000);\n```\n\n#Usage\n\n##new Tilesplash(connection_details, [cacheType])\n\ncreates a new tilesplash server using the given postgres database\n\n```javascript\nvar app = new Tilesplash('postgres://tiles@localhost/tile_database');\n```\n\nTo cache using redis, pass `'redis'` as the second argument. Otherwise an in-process cache will be used.\n\n###Tilesplash.server\n\nan [express](http://expressjs.com/) object, mostly used internally but you can use it to add middleware for authentication, browser caching, gzip, etc.\n\n###Tilesplash.layer(name, [middleware, ...] callback)\n\n__name__: the name of your layer. Tiles will be served at /__name__/z/x/y.topojson\n\n__middleware__: a [middleware function](#middleware)\n\n__callback__: your tile building function with the following arguments. function([tile](#tile), [render](#render))\n\n\n####Simple layer\n\nThis layer renders tiles containing geometry from the `the_geom` column in `test_table`\n\n```javascript\napp.layer('simpleLayer', function(tile, render){\n  render('SELECT ST_AsGeoJSON(the_geom) as the_geom_geojson FROM test_table WHERE ST_Intersects(the_geom, !bbox_4326!)');\n});\n```\n\n####Combined layers\n\nTilesplash can render tiles from multiple queries at once\n\n```javascript\napp.layer('multiLayer', function(tile, render){\n  render({\n    circles: 'SELECT ST_AsGeoJSON(the_geom) as the_geom_geojson FROM circles WHERE ST_Intersects(the_geom, !bbox_4326!)',\n    squares: 'SELECT ST_AsGeoJSON(the_geom) as the_geom_geojson FROM squares WHERE ST_Intersects(the_geom, !bbox_4326!)'\n  });\n});\n```\n\n####Escaping variables\n\nTilesplash has support for escaping variables in sql queries. You can do so by passing an array instead of a string wherever a sql string is accepted.\n\n```javascript\napp.layer('escapedLayer', function(tile, render){\n  render(['SELECT ST_AsGeoJSON(the_geom) as the_geom_geojson FROM points WHERE ST_Intersects(the_geom, !bbox_4326!) AND state=$1', 'California']);\n});\n\napp.layer('escapedMultiLayer', function(tile, render){\n  render({\n    hotels: ['SELECT ST_AsGeoJSON(the_geom) as the_geom_geojson FROM hotels WHERE ST_Intersects(the_geom, !bbox_4326!) AND state=$1', 'California'],\n    restaurants: ['SELECT ST_AsGeoJSON(the_geom) as the_geom_geojson FROM restaurants WHERE ST_Intersects(the_geom, !bbox_4326!) AND state=$1', 'California']\n  });\n});\n```\n\n####Restricting zoom level\n\nSometimes you only want a layer to be visible on certain zoom levels. To do that, we simply render an empty tile when tile.z is too low or too high.\n\n```javascript\napp.layer('zoomDependentLayer', function(tile, render){\n  if (tile.z < 8 || tile.z > 20) {\n    render.empty(); //render an empty tile\n  } else {\n    render('SELECT ST_AsGeoJSON(the_geom) as the_geom_geojson FROM points WHERE ST_Intersects(the_geom, !bbox_4326!)');\n  }\n});\n```\n\nYou can also adapt your layer by zoom level to show different views in different situations.\n\nIn this example we show data from the `heatmap` table when the zoom level is below 8, data from `points` up to zoom 20, and empty tiles when you zoom in further than that.\n\n```javascript\napp.layer('fancyLayer', function(tile, render){\n  if (tile.z < 8) {\n    render('SELECT ST_AsGeoJSON(the_geom) as the_geom_geojson FROM heatmap WHERE ST_Intersects(the_geom, !bbox_4326!)');\n  } else if (tile.z > 20) {\n    render.empty();\n  } else {\n    render('SELECT ST_AsGeoJSON(the_geom) as the_geom_geojson FROM points WHERE ST_Intersects(the_geom, !bbox_4326!)');\n  }\n});\n```\n\n##Middleware\n\nMiddleware allows you to easily extend tilesplash to add additional functionality. Middleware is defined like this:\n\n```javascript\nvar userMiddleware = function(req, res, tile, next){\n  tile.logged_in = true;\n  tile.user_id = req.query.user_id;\n  next();\n};\n```\n\nYou can layer include this in your layers\n\n```javascript\napp.layer('thisOneHasMiddleware', userMiddleware, function(tile, render){\n  if (!tile.logged_in) {\n    render.error();\n  } else {\n    render(['SELECT ST_AsGeoJSON(the_geom) as the_geom_geojson FROM placesVisited WHERE ST_Intersects(the_geom, !bbox_4326!) AND visitor=$1', tile.user_id]);\n  }\n});\n```\n\nMiddleware can be synchronous or asynchronous, just be sure to call `next()` when you're done!\n\n##tile\n\n`tile` is a parameter passed to middleware and layer callbacks. It is an object containing information about the tile being requested. It will look something like this:\n\n```javascript\n{\n  x: 100,\n  y: 100,\n  z: 10,\n  bounds: [w, s, e, n] //output from SphericalMercator.bounds(x,y,z) using https://github.com/mapbox/node-sphericalmercator\n  bbox: 'BBOX SQL for webmercator',\n  bbox_4326: 'BBOX SQL for 4326 projection' //you probably need this\n}\n```\n\nAnything in __tile__ can be substituted into your SQL query by wrapping it in exclamation marks like `!this!`\n\nYou can add custom items into __tile__ like so:\n\n```javascript\ntile.table = \"states\";\nrender('SELECT ST_AsGeoJSON(the_geom) as the_geom_geojson FROM !table! WHERE !bbox!')\n```\n\nNote that when you interpolate tile variables into your queries with the exclamation point syntax, that data will __not be escaped__. This allows you to insert custom SQL from tile variables, like with `!bbox!`, but it can be a security risk if you allow any user input to be interpolated that way.\n\nWhen you want to use user input in a query, see [Escaping variables](#escaping-variables) above.\n\n##render\n\n`render` is the second argument passed to your layer callback function. You can use it to render different kinds of tiles.\n\n###render(sql)\n\nRuns a SQL query and displays the result as a tile\n\n###render(object)\n\nRuns multiple SQL queries and renders them in seperate topojson layers. See [Combined layers](#combined-layers) above.\n\n###render.query()\n\nAlias of render()\n\n###render.queryFile(fileName)\n\nUse this if your SQL is really long and/or you want to keep it seperate.\n\n```javascript\napp.layer('complicatedLayer', function(tile, render){\n  render.queryFile('important_stuff/advanced_tile.sql');\n});\n```\n\n###render.empty()\n\nRenders an empty tile\n\n###render.error()\n\nReplies with a 500 error\n\n###render.raw(string or http code)\n\nSends a raw reply. I can't think of any reason you would want to do this, but feel free to experiment.\n\n```javascript\napp.layer('smileyLayer', function(tile, render){\n  render.raw(':)');\n});\n```\n\n```javascript\napp.layer('notThereLayer', function(tile, render){\n  render.raw(404);\n});\n```\n\n###render.rawFile(fileName)\n\nReplies with the specified file\n\n```javascript\napp.layer('staticLayer', function(tile, render){\n  render.rawFile('thing.topojson');\n});\n```\n\n##Caching\n\nCaching is very important. By default, Tilesplash uses an in-memory cache. You can use redis instead by passing `'redis'` as the second argument when initializing a Tilesplash server.\n\nThere are two ways to implement caching. You can either do it globally or on a layer by layer basis.\n\n###app.cache([keyGenerator], ttl)\n\nUse this to define caching across your entire application\n\n__`keyGenerator(tile)`__\n\nkeyGenerator is a function that takes a `tile` object as it's only parameter and returns a cache key (__string__)\n\nIf you don't specify a key generator, `app.defaultCacheKeyGenerator` will be used, which returns a key derived from your database connection, tile layer, and tile x, y, and z.\n\n__`ttl`__\n\nTTL stands for time-to-live. It's how long tiles will remain in your cache, and it's defined in milliseconds. For most applications, anywhere between one day (86400000) to one week (604800000) should be fine.\n\n__Example__\n\nIn this example, we have `tile.user_id` available to us and we don't want to show one user tiles belonging to another user. By starting with `app.defaultCacheKeyGenerator(tile)` we get a cache key based on things we already want to cache by (like `x`, `y`, and `z`) and we can then add `user_id` to prevent people from seeing cached tiles unless their `user_id` matches.\n\n```javascript\napp.cache(function(tile){\n  return app.defaultCacheKeyGenerator(tile) + ':' + tile.user_id; //cache by tile.user_id as well\n}, 1000 * 60 * 60 * 24 * 30); //ttl 30 days\n```\n\n###this.cache([keyGenerator], ttl)\n\nLayer-specific caching works identically to global caching as defined above, except that it only applies to one layer and you define it within that layer.\n\nIn this example, slowLayer uses the same key generator as the rest of the app, but specifies a longer TTL.\n\n```javascript\napp.cache(keyGenerator, 1000 * 60 * 60 * 24); //cache for one day\n\napp.layer('slowLayer', function(tile, render){\n  this.cache(1000 * 60 * 60 * 24 * 30); //cache for 30 days\n\n  render.queryFile('slowQuery.sql');\n});\n```\n\nIn this example, only slowLayer is cached.\n\n```javascript\napp.layer('fastLayer', function(tile, render){\n  render.queryFile('fastQuery.sql');\n});\n\nvar userMiddleware = function(req, res, tile, next){\n  tile.user_id = 1;\n  next();\n};\n\napp.layer('slowLayer', userMiddleware, function(tile, render){\n  this.cache(function(tile){\n    return app.defaultCacheKeyGenerator(tile) + ':' + tile.user_id;\n  }, 1000 * 60 * 60 * 24); //cache for one day\n\n  render.queryFile('slowQuery.sql');\n});\n```\n## Client Use\nThere are a number of ways to use topojson vector tiles on the client. Here are a few examples (FYI _not_ currently using a TileSplash endpoint):\n\n* [using leaflet](http://bl.ocks.org/wboykinm/7393674)\n* [using d3.geo.tile](http://bl.ocks.org/wboykinm/7388233)\n* [using openlayers 3](http://bl.ocks.org/wboykinm/cc509eb2763ca1ba9293)\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/faradayio/tilesplash/issues"
  },
  "_id": "tilesplash@1.2.0",
  "_from": "tilesplash@~1.2.0"
}
